"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Event = void 0;
const app_root_path_1 = __importDefault(require("app-root-path"));
const form_data_1 = __importDefault(require("form-data"));
const luxon_1 = require("luxon");
const fs = __importStar(require("node:fs"));
const path = __importStar(require("node:path"));
const HttpClient_1 = require("../common/HttpClient");
const utils_1 = require("../utils");
const UrlClass_1 = require("./UrlClass");
const types_1 = require("./types");
const lodash_1 = __importDefault(require("lodash"));
let config = undefined;
try {
    config = app_root_path_1.default.require('/garmin.config.json');
}
catch (e) {
    // Do nothing
}
var Event;
(function (Event) {
    Event["sessionChange"] = "sessionChange";
})(Event = exports.Event || (exports.Event = {}));
class GarminConnect {
    // private oauth1: OAuth;
    constructor(credentials = config, domain = 'garmin.com') {
        if (!credentials) {
            throw new Error('Missing credentials');
        }
        this.credentials = credentials;
        this.url = new UrlClass_1.UrlClass(domain);
        this.client = new HttpClient_1.HttpClient(this.url);
        this._userHash = undefined;
        this.listeners = {};
    }
    async login(username, password) {
        if (username && password) {
            this.credentials.username = username;
            this.credentials.password = password;
        }
        await this.client.login(this.credentials.username, this.credentials.password);
        return this;
    }
    exportTokenToFile(dirPath) {
        if (!(0, utils_1.checkIsDirectory)(dirPath)) {
            (0, utils_1.createDirectory)(dirPath);
        }
        // save oauth1 to json
        if (this.client.oauth1Token) {
            (0, utils_1.writeToFile)(path.join(dirPath, 'oauth1_token.json'), JSON.stringify(this.client.oauth1Token));
        }
        if (this.client.oauth2Token) {
            (0, utils_1.writeToFile)(path.join(dirPath, 'oauth2_token.json'), JSON.stringify(this.client.oauth2Token));
        }
    }
    loadTokenByFile(dirPath) {
        if (!(0, utils_1.checkIsDirectory)(dirPath)) {
            throw new Error('loadTokenByFile: Directory not found: ' + dirPath);
        }
        let oauth1Data = fs.readFileSync(path.join(dirPath, 'oauth1_token.json'));
        const oauth1 = JSON.parse(oauth1Data);
        this.client.oauth1Token = oauth1;
        let oauth2Data = fs.readFileSync(path.join(dirPath, 'oauth2_token.json'));
        const oauth2 = JSON.parse(oauth2Data);
        this.client.oauth2Token = oauth2;
    }
    exportToken() {
        if (!this.client.oauth1Token || !this.client.oauth2Token) {
            throw new Error('exportToken: Token not found');
        }
        return {
            oauth1: this.client.oauth1Token,
            oauth2: this.client.oauth2Token
        };
    }
    // from db or localstorage etc
    loadToken(oauth1, oauth2) {
        this.client.oauth1Token = oauth1;
        this.client.oauth2Token = oauth2;
    }
    async getUserSettings() {
        return this.client.get(this.url.USER_SETTINGS);
    }
    async getUserProfile() {
        return this.client.get(this.url.USER_PROFILE);
    }
    async getActivities(start, limit) {
        return this.client.get(this.url.ACTIVITIES, {
            params: { start, limit }
        });
    }
    async getActivity(activity) {
        if (!activity.activityId)
            throw new Error('Missing activityId');
        return this.client.get(this.url.ACTIVITY + activity.activityId);
    }
    async countActivities() {
        return this.client.get(this.url.STAT_ACTIVITIES, {
            params: {
                aggregation: 'lifetime',
                startDate: '1970-01-01',
                endDate: luxon_1.DateTime.now().toFormat('yyyy-MM-dd'),
                metric: 'duration'
            }
        });
    }
    async downloadOriginalActivityData(activity, dir, type = 'zip') {
        if (!activity.activityId)
            throw new Error('Missing activityId');
        if (!(0, utils_1.checkIsDirectory)(dir)) {
            (0, utils_1.createDirectory)(dir);
        }
        let fileBuffer;
        if (type === 'tcx') {
            fileBuffer = await this.client.get(this.url.DOWNLOAD_TCX + activity.activityId);
        }
        else if (type === 'gpx') {
            fileBuffer = await this.client.get(this.url.DOWNLOAD_GPX + activity.activityId);
        }
        else if (type === 'kml') {
            fileBuffer = await this.client.get(this.url.DOWNLOAD_KML + activity.activityId);
        }
        else if (type === 'zip') {
            fileBuffer = await this.client.get(this.url.DOWNLOAD_ZIP + activity.activityId, {
                responseType: 'arraybuffer'
            });
        }
        else {
            throw new Error('downloadOriginalActivityData - Invalid type: ' + type);
        }
        (0, utils_1.writeToFile)(path.join(dir, `${activity.activityId}.${type}`), fileBuffer);
    }
    async uploadActivity(file, format = 'fit') {
        var _a;
        const detectedFormat = (_a = (format || path.extname(file))) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (!lodash_1.default.includes(types_1.UploadFileType, detectedFormat)) {
            throw new Error('uploadActivity - Invalid format: ' + format);
        }
        const fileBuffer = fs.createReadStream(file);
        const form = new form_data_1.default();
        form.append('userfile', fileBuffer);
        const response = this.client.post(this.url.UPLOAD + '.' + format, form, {
            headers: {
                'Content-Type': form.getHeaders()['content-type']
            }
        });
        return response;
    }
    async deleteActivity(activity) {
        if (!activity.activityId)
            throw new Error('Missing activityId');
        await this.client.post(this.url.ACTIVITY + activity.activityId, null, {
            headers: {
                'X-Http-Method-Override': 'DELETE'
            }
        });
    }
}
exports.default = GarminConnect;
//# sourceMappingURL=GarminConnect.js.map